<h1>P0: Refreshing Your Background</h1>
CMPSC 473, FALL 2018<br/>
This project is not for evaluation. This is to get you familiarized with the
tools and coding practices
<hr>
<h1 id="understanding-the-basics">Understanding the basics</h1>
<p>To be able to do this project and further projects you are supposed to understand the followings:</p>
<ol>
<li><p>Logging into a Linux machine (<span>ssh, VPN, 2FA</span>) and using basic Linux shell and commands</p></li>
<li><p>How to compile the project.</p></li>
<li><p>How to run the project.</p></li>
<li><p>Basic <span>gdb</span> as your debugger</p></li>
<li><p>Getting <span>gdb</span> commands list</p></li>
</ol>
<p>Also we are going to use GitHub for our source code management and version controlling. A separate <span>git</span> manual will be provided which by reading that you should be able to understand and do the followings:</p>
<ol>
<li><p>Cloning a remote repository to a local one</p></li>
<li><p>Committing your changes with a proper message</p></li>
<li><p>Pushing your changes to the remote repository</p></li>
<li><p>Collaborating with your teammate(s) using *branching*, *forking*, *stashing* etc.</p></li>
</ol>
<h1 id="sec:start">Getting Started</h1>
<p>After accepting the invitational link to the Github Classroom @PSU473, you will be given access to your own private repository named <span>p0-&lt;your github username&gt;</span> containing all the files needed for completing P0. When you open this repository, you will find 3 folders, named <span>prog1</span>, ..., <span>prog3</span>. These folders contain the files described in Section [sec:tasks]. On the web-page of this repository, you will find a link to clone it. To clone copy the link and type on the command line:<br /><span>$ git clone <span class="math"> &lt; </span>link_of_the_repository<span class="math"> &gt; </span></span><br />You will find additional information on using GitHub and other important documents uploaded in a separate document on canvas.</p>
<p>As mentioned in class, you may do the bulk of your work on any Linux (virtual) machine of your choosing. However, the results in your report must be carried out on CSE department’s Linux-based teaching machines. These machines are named <span>cse-p204instxx.cse.psu.edu</span> (where <span>xx</span> is a machine number). The reason for asking you to report results on these machines is to have relative consistency/uniformity in your measurements.</p>
<h1 id="sec:tasks">Description of Tasks</h1>
<ol>
<li><p><span><strong>Task one:</strong></span> The program <span>prog1.c</span> calls a recursive function which has a local and a dynamically allocated variable. this program will crash due a bug we have introduced into it. Use the <span>Makefile</span> that we have provided to compile the program. Execute it. The program will exit with an error printed on the console. You are to compile the program with 32 bit and 64 bit options and carry out the following tasks separately for each:</p>
<ol>
<li><p>Observe and report the differences in the following for the 32 bit and 64 bit executables: (i) size of compiled code, (ii) size of code during run time, (iii) size of linked libraries.</p></li>
<li><p>Use <span>gdb</span> to find the program statement that caused the error. See some tips on <span>gdb</span> in the Appendix if needed.</p></li>
<li><p>Explain the cause of this error.</p></li>
</ol></li>
<li><p><span><strong>Task two:</strong></span> Consider the program <span>prog2.c</span>. It calls a recursive function which has a local and a dynamically allocated variable. Like the last time, this program will crash due to a bug that we have introduced in it. Use the provided <span>Makefile</span> to compile the program. Again, create both a 32 bit and a 64 bit executable. For each of these, execute it. Upon executing, you will see an error on the console before the program terminates. You are to carry out the following tasks:</p>
<ol>
<li><p>Observe and report the differences in the following for the 32 bit and 64 bit executables: (i) size of compiled code, (ii) size of code during run time, (iii) size of linked libraries.</p></li>
<li><p>Use <span>valgrind</span> to find the cause of the error including the program statement causing it. For this, simply run <span>valgrind prog2</span> on the command line.</p></li>
<li><p>How is this error different than the one for <span>prog1</span>?</p></li>
</ol></li>
<li><p><span><strong>Task three:</strong></span> The program <span>prog3.c</span> may seem to be error-free. But when executing under <span>valgrind</span>, you will see many errors. You are to perform the following tasks:</p>
<ol>
<li><p>Describe the cause and nature of these errors. How would you fix them?</p></li>
</ol></li>
</ol>
<h1 id="sec:grad">Submission and Grading</h1>
<p>You will submit all your source files, Makefiles, and READMEs (the last to convey something non-trivial we may need to know to use your code). You are to submit a report answering all the questions posed above into your github repo.</p>
<h1 id="appendix" class="unnumbered">Appendix</h1>
<p>We offer some useful hints here.</p>
<ul>
<li><p><span><strong>Quick notes on <span>gdb</span>:</strong></span></p>
<ol>
<li><p>To run a program <span>prog1</span> under <span>gdb</span>, simply execute<br /><span>$ gdb prog1</span></p></li>
<li><p>While running under <span>gdb</span>’s control, you can add breakpoints in the program to ease the debugging process. To add a breakpoint, type<br /><span>$ break <span class="math"> &lt; </span>linenumber<span class="math"> &gt; </span></span></p></li>
<li><p>To run the code type<br /><span>$ r</span></p></li>
<li><p>To continue running the program after a breakpoint is hit, type<br /><span>$ c</span></p></li>
<li><p>To inspect the stack using <span>gdb</span>, type<br /><span>$ backtrace</span> or<br /><span>$ backtrace full</span> (to display contents of local variables)</p></li>
<li><p>To get information about individual frames, type<br /><span>$ info frame <span class="math"> &lt; </span>frame number<span class="math"> &gt; </span></span><br />E.g., if you want to see information about frame 5 (assuming your program has made 6 recursive function calls, since frame number starts from 0), then the command would look like<br /><span>$ info frame 5</span></p></li>
<li><p>To get size of a frame, subtract frame addresses of two consecutive frames.</p></li>
</ol></li>
<li><p>To compile the code using 32/64 bit options, add the <span>-m&lt;architecture&gt;</span> flag to the compile command in the Makefile. E.g., to compile with the 32 bit option:<br /><span>$ gcc -g -m32 prog.c -o prog</span></p></li>
<li><p>To find the size of an executable (including its code vs. data segments), consider using the <span>size</span> command. Look at its man pages.</p></li>
<li><p>To find the size of code during run time, type the following while the code is in execution:<br /><span>$ pmap PID | grep “total”</span><br />To see memory allocated to each section of the process, type<br /><span>$ pmap PID</span></p></li>
</ul>
